Question 1
What is the purpose of having an individual handler function for each exception/interrupt? (i.e., if all exceptions/interrupts were delivered to the same h\
andler, what feature that exists in the current implementation could not be provided?)

     Accrording to the reading, given the nature of the different kinds of control transfer, different actions need to be taken in order
     to them (interupts vs exceptions and the subsets in each group). For exceptions, faults, traps and aborts all transfer control at
     diffferent times relative to the instruction that cuases them. In addition faults and traps return to a state that allows restarting
     while abort does not. If everything was handled the same, we wouldnt be able to have a subset of exceptions that are restartable,
     basically leaving us with now choice but to abort every time. When considering interrupts, think abut how if the NMI handler is
     executing then the processor ignores any other interrupt flags. THis is another example of the diversity of reactions to different
     interrupts/exceptions we would be sacrificing if we only handled them one way.

Question 2
Did you have to do anything to make the user/softint program behave correctly? The grade script expects it to produce a general protection fault (trap 13),\
 but softint’s code says int $14. Why should this produce interrupt vector 13? What happens if the kernel actually allows softint’s int $14 instruction to \
invoke the kernel’s page fault handler (which is interrupt vector 14)?

    Nothing was	needed to make softint program behave correctly. The program tried to throw an exception while not in kernel mode, hence the requisite	
    priveledges	were not present at the	time of	the call, this is one of the criteria for interupt 13. If the kernel allowed this to happen then programs
    in user space would	be able	to make	control	transfers to kernel space at will, this	could lead to problems.

Question 3
The breakpoint test case will either generate a break point exception or a general protection fault depending on how you initialized the break point entry in the IDT (i.e., your call to SETGATE from trap_init). Why? How do you need to set it up in order to get the breakpoint exception to work as specified above and what incorrect setup would cause it to trigger a general protection fault?

    Interrupt 13 gets invoked for many reasons that do not cause other exceptions,
    one of the reasons (per the documentation) is the violation of priveledge rules.
    Since a breakpoint is somthing invoked by the user so we need to set the DPL in
    SETGATE to 3 to correspond to the CPL. If SETAGTE is passed 0 then it returns a 
    interrupt 13 becuase it violates the priveledge as described. We must set DPL to 3 to get the sepcififed handling.

Question 4
What do you think is the point of these mechanisms, particularly in light of what the user/softint test program does?

    Like in question 2, it is important to allow different functionality for 
    different situations, allowing the SETGATE calls to take different DPL settings
    stops users from invoking exceptions that are really for the kernel. 

Question 5

What causes this page fault? You don’t need to fix it, but consider how you might and explain why it happens.

    We programmed backtrace to pull five arguements off the stack, when we do this here we dont check if we go off the stack into unmapped memory. Because of this we can access unmapped memory and cause a page fault. To fix this we should add some code similar to mem_check_asert inside of backtrace to see if the user has permission there. 
