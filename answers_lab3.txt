Question 1
What is the purpose of having an individual handler function for each exception/interrupt? (i.e., if all exceptions/interrupts were delivered to the same h\
andler, what feature that exists in the current implementation could not be provided?)

     Accrording to the reading, given the nature of the different kinds of control transfer, different actions need to be taken in order
     to them (interupts vs exceptions and the subsets in each group). For exceptions, faults, traps and aborts all transfer control at
     diffferent times relative to the instruction that cuases them. In addition faults and traps return to a state that allows restarting
     while abort does not. If everything was handled the same, we wouldnt be able to have a subset of exceptions that are restartable,
     basically leaving us with now choice but to abort every time. When considering interrupts, think abut how if the NMI handler is
     executing then the processor ignores any other interrupt flags. THis is another example of the diversity of reactions to different
     interrupts/exceptions we would be sacrificing if we only handled them one way.

Question 2
Did you have to do anything to make the user/softint program behave correctly? The grade script expects it to produce a general protection fault (trap 13),\
 but softint’s code says int $14. Why should this produce interrupt vector 13? What happens if the kernel actually allows softint’s int $14 instruction to \
invoke the kernel’s page fault handler (which is interrupt vector 14)?

    Nothing was	needed to make softint program behave correctly. The program tried to throw an exception while not in kernel mode, hence the requisite	
    priveledges	were not present at the	time of	the call, this is one of the criteria for interupt 13. If the kernel allowed this to happen then programs
    in user space would	be able	to make	control	transfers to kernel space at will, this	could lead to problems.

